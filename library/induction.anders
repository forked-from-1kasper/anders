module induction where
import library/sigma

option girard true

-- Steve Awodey, Nicola Gambino, Kristina Sojakova
-- Inductive Types in Homotopy Type Theory
-- https://arxiv.org/pdf/1201.3898.pdf

-- Jasper Hugunin
-- Why not W?
-- https://jashug.github.io/papers/whynotw.pdf

-- Primitives: 0, 1, 2, W

def 0-ind (C: 𝟎 → U) (z: 𝟎) : C z := ind₀ (C z) z
def 1-ind (C: 𝟏 → U) (x: C ★) (z: 𝟏) : C z := ind₁ C x z
def 2-ind (C: 𝟐 → U) (x: C 0₂) (y: C 1₂) (z: 𝟐) : C z := ind₂ C x y z
def W-ind (A : U) (B : A → U) (C : (W (x : A), B x) → U)
    (g : Π (x : A) (f : B x → (W (x : A), B x)), (Π (b : B x), C (f b)) → C (sup A B x f))
    (a : A) (f : B a → (W (x : A), B x)) (b : B a) : C (f b) := indᵂ A B C g (f b)

def indᵂ-β (A : U) (B : A → U) (C : (W (x : A), B x) → U)
    (g : Π (x : A) (f : B x → (W (x : A), B x)), (Π (b : B x), C (f b)) → C (sup A B x f))
    (a : A) (f : B a → (W (x : A), B x))
  : PathP (<_> C (sup A B a f)) (indᵂ A B C g (sup A B a f)) (g a f (λ (b : B a), indᵂ A B C g (f b)))
 := <_> g a f (λ (b : B a), indᵂ A B C g (f b))

def trans-W (A : I → U) (B : Π (i : I), A i → U) (a : A 0) (f : B 0 a → (W (x : A 0), B 0 x)) : W (x : A 1), B 1 x :=
sup (A 1) (B 1) (transp (<i> A i) 0 a) (transp (<i> B i (transFill (A 0) (A 1) (<j> A j) a @ i) → (W (x : A i), B i x)) 0 f)

def trans-W′ (A : I → U) (B : Π (i : I), A i → U) (a : A 0) (f : B 0 a → (W (x : A 0), B 0 x)) : W (x : A 1), B 1 x :=
transp (<i> W (x : A i), B i x) 0 (sup (A 0) (B 0) a f)

def trans-W-is-correct (A : I → U) (B : Π (i : I), A i → U) (a : A 0) (f : B 0 a → (W (x : A 0), B 0 x)) :
   Path (W (x : A 1), B 1 x) (trans-W A B a f) (trans-W′ A B a f) :=
<_> trans-W A B a f

--def hcomp-W (A : U) (B : A → U) (r : I) (a : I → Partial A r)
--   (f : Π (i : I), PartialP [(r = 1) → B (a i 1=1) → (W (x : A), B x)] r)
--   (a₀ : A[r ↦ a 0]) (f₀ : (B (ouc a₀) → (W (x : A), B x))[r ↦ f 0]) : W (x : A), B x :=
--sup A B (hcomp A r a (ouc a₀)) (hcomp (B (hcomp A r a (ouc a₀)) → (W (x : A), B x)) r
--   (λ (i : I), [(r = 1) → λ (b : B (a 1 1=1)), (f i 1=1) (transp (<j> B (a (-j ∨ i) 1=1)) 0 b)]) ?)

def hcomp-W′ (A : U) (B : A → U) (r : I) (a : I → Partial A r)
   (f : Π (i : I), PartialP [(r = 1) → B (a i 1=1) → (W (x : A), B x)] r)
   (a₀ : A[r ↦ a 0]) (f₀ : (B (ouc a₀) → (W (x : A), B x))[r ↦ f 0]) : W (x : A), B x :=
hcomp (W (x : A), B x) r (λ (i : I), [(r = 1) → sup A B (a i 1=1) (f i 1=1)]) (sup A B (ouc a₀) (ouc f₀))

-- Derivable Induction: N, +, Maybe, Fin, Vec, 3, 4

def ℕ := W (x : 𝟐), ind₂ (λ (_ : 𝟐), U) 𝟎 𝟏 x
def ℕ-ctor := ind₂ (λ (_ : 𝟐), U) 𝟎 𝟏
def zero : ℕ := sup 𝟐 ℕ-ctor 0₂ (ind₀ ℕ)
def succ (n : ℕ) : ℕ := sup 𝟐 ℕ-ctor 1₂ (λ (x : 𝟏), n)

def 𝟎⟶ℕ (C : ℕ → U) (f : 𝟎 → ℕ) : C zero → C (sup 𝟐 ℕ-ctor 0₂ f)
 := transp (<i> C (sup 𝟐 ℕ-ctor 0₂ (λ (x : 𝟎), ind₀ (PathP (<_> ℕ) (ind₀ ℕ x) (f x)) x @ i))) 0

def 𝟏⟶ℕ (C : ℕ → U) (f : 𝟏 → ℕ) : C (succ (f ★)) → C (sup 𝟐 ℕ-ctor 1₂ f)
 := transp (<i> C (sup 𝟐 ℕ-ctor 1₂ (λ (x : 𝟏), ind₁ (λ (y : 𝟏), PathP (<_> ℕ) (f ★) (f y)) (<_> f ★) x @ i))) 0

def ℕ-ind (C : ℕ → U) (z : C zero) (s : Π (n : ℕ), C n → C (succ n)) : Π (n : ℕ), C n
 := indᵂ 𝟐 ℕ-ctor C
    (ind₂ (λ (x : 𝟐), Π (f : ℕ-ctor x → ℕ), (Π (b : ℕ-ctor x), C (f b)) → C (sup 𝟐 ℕ-ctor x f))
          (λ (f : 𝟎 → ℕ) (g : Π (x : 𝟎), C (f x)), 𝟎⟶ℕ C f z)
          (λ (f : 𝟏 → ℕ) (g : Π (x : 𝟏), C (f x)), 𝟏⟶ℕ C f (s (f ★) (g ★))))

def ℕ-rec (C : U) (z : C) (s : ℕ → C → C) : ℕ → C := ℕ-ind (λ (_ : ℕ), C) z s
def ℕ-iter (C : U) (z : C) (s : C → C) : ℕ → C := ℕ-rec C z (λ (_ : ℕ), s)
def ℕ-case (C : U) (z s : C) : ℕ → C := ℕ-iter C z (λ (_ : C), s)

def plus : ℕ → ℕ → ℕ := ℕ-iter (ℕ → ℕ) (idfun ℕ) (∘ ℕ ℕ ℕ succ)
def mult : ℕ → ℕ → ℕ := ℕ-rec (ℕ → ℕ) (\(_: ℕ), zero) (\(_: ℕ) (x: ℕ → ℕ) (m: ℕ), plus m (x m))

def one : ℕ := succ zero
def two : ℕ := succ one
def three : ℕ := succ two
def 5 : ℕ := plus two three
def 10 : ℕ := mult 5 two
def 55 : ℕ := plus (mult 5 10) 5

def + (A B: U) : U := Σ (x : 𝟐), ind₂ (λ (_ : 𝟐), U) A B x
def inl (A B : U) (a : A) : + A B := (0₂, a)
def inr (A B : U) (b : B) : + A B := (1₂, b)
def +-ind (A B : U) (C : + A B → U) (f : Π (x : A), C (inl A B x)) (g : Π (y : B), C (inr A B y)) (w : + A B) : C w
 := ind₂ (λ (x : 𝟐), Π (u : ind₂ (λ (_ : 𝟐), U) A B x), C (x, u)) f g w.1 w.2

def maybe (A : U) : U := + 𝟏 A
def nothing (A : U) : maybe A := (0₂, ★)
def just (A : U) (a : A) : maybe A := (1₂, a)
def maybe-ind (A : U) (P: maybe A -> U) (n: P (nothing A)) (j: Π (x: A), P (just A x)) : Π (a: maybe A), P a
 := +-ind 𝟏 A P (ind₁ (λ (x : 𝟏), P (0₂, x)) n) j

def Fin : ℕ → U := ℕ-iter U 𝟎 (+ 𝟏)
def fzero (n : ℕ) : Fin (succ n) := (0₂, ★)
def fsucc (n : ℕ) (m : Fin n) : Fin (succ n) := (1₂, m)
def Fin-ind (T : Π (n : ℕ), Fin n → U) (z : Π (n : ℕ), T (succ n) (fzero n))
   (s : Π (n : ℕ) (x : Fin n), T n x → T (succ n) (fsucc n x)) (m : ℕ) (x : Fin m) : T m x :=
ℕ-ind (λ (k : ℕ), Π (x : Fin k), T k x) (λ (x : 𝟎), ind₀ (T zero x) x)
   (λ (k : ℕ) (f : Π (x : Fin k), T k x),
      +-ind 𝟏 (Fin k) (T (succ k))
         (ind₁ (λ (w : 𝟏), T (succ k) (0₂, w)) (z k))
         (λ (w : Fin k), s k w (f w))) m x

def Vec (A : U) : ℕ → U := ℕ-iter U 𝟏 (λ (X : U), A × X)
def vzero (A : U) : Vec A zero := ★
def vsucc (A : U) (n : ℕ) (head : A) (tail : Vec A n) : Vec A (succ n) := (head, tail)
def Vec-ind (A : U) (T : Π (n : ℕ), Vec A n → U) (z : T zero (vzero A))
   (s : Π (n : ℕ) (x : A) (v : Vec A n), T n v → T (succ n) (vsucc A n x v))
   (m : ℕ) : Π (x : Vec A m), T m x :=
ℕ-ind (λ (k : ℕ), Π (x : Vec A k), T k x) (ind₁ (T zero) z)
   (λ (k : ℕ) (f : Π (x : Vec A k), T k x) (y : Vec A (succ k)),
      s k y.1 y.2 (f y.2)) m

def Vec-rec (A B : U) (z : B) (s : Π (n : ℕ), A → Vec A n → B → B) (m : ℕ) : Vec A m → B :=
Vec-ind A (λ (n : ℕ) (_ : Vec A n), B) z s m

def Vec-map (A B : U) (f : A → B) (n : ℕ) : Vec A n → Vec B n :=
Vec-ind A (λ (k : ℕ) (_ : Vec A k), Vec B k) ★
   (λ (k : ℕ) (x : A) (_ : Vec A k), vsucc B k (f x)) n

def 𝟑 : U := + 𝟏 𝟐
def 0₃ : 𝟑 := inl 𝟏 𝟐 ★
def 1₃ : 𝟑 := inr 𝟏 𝟐 0₂
def 2₃ : 𝟑 := inr 𝟏 𝟐 1₂
def ind₃ (C : 𝟑 → U) (c₀ : C 0₃) (c₁ : C 1₃) (c₂ : C 2₃) : Π (x : 𝟑), C x
 := +-ind 𝟏 𝟐 C (ind₁ (λ (x : 𝟏), C (0₂, x)) c₀) (ind₂ (λ (x : 𝟐), C (1₂, x)) c₁ c₂)

def 𝟒 : U := + 𝟐 𝟐
def 0₄ : 𝟒 := inl 𝟐 𝟐 0₂
def 1₄ : 𝟒 := inl 𝟐 𝟐 1₂
def 2₄ : 𝟒 := inr 𝟐 𝟐 0₂
def 3₄ : 𝟒 := inr 𝟐 𝟐 1₂
def ind₄ (C : 𝟒 → U) (c₀ : C 0₄) (c₁ : C 1₄) (c₂ : C 2₄) (c₃ : C 3₄) : Π (x : 𝟒), C x
 := +-ind 𝟐 𝟐 C (ind₂ (λ (x : 𝟐), C (0₂, x)) c₀ c₁) (ind₂ (λ (x : 𝟐), C (1₂, x)) c₂ c₃)

def 𝟓 : U := + 𝟐 𝟑
def 0₅ : 𝟓 := inl 𝟐 𝟑 0₂
def 1₅ : 𝟓 := inl 𝟐 𝟑 1₂
def 2₅ : 𝟓 := inr 𝟐 𝟑 0₃
def 3₅ : 𝟓 := inr 𝟐 𝟑 1₃
def 4₅ : 𝟓 := inr 𝟐 𝟑 2₃
def ind₅ (C : 𝟓 → U) (c₀ : C 0₅) (c₁ : C 1₅) (c₂ : C 2₅) (c₃ : C 3₅) (c₄ : C 4₅) : Π (x : 𝟓), C x
 := +-ind 𝟐 𝟑 C (ind₂ (λ (x : 𝟐), C (0₂, x)) c₀ c₁) (ind₃ (λ (x : 𝟑), C (1₂, x)) c₂ c₃ c₄)

def 𝟔 : U := + 𝟑 𝟑
def 0₆ : 𝟔 := inl 𝟑 𝟑 0₃
def 1₆ : 𝟔 := inl 𝟑 𝟑 1₃
def 2₆ : 𝟔 := inl 𝟑 𝟑 2₃
def 3₆ : 𝟔 := inr 𝟑 𝟑 0₃
def 4₆ : 𝟔 := inr 𝟑 𝟑 1₃
def 5₆ : 𝟔 := inr 𝟑 𝟑 2₃
def ind₆ (C : 𝟔 → U) (c₀ : C 0₆) (c₁ : C 1₆) (c₂ : C 2₆) (c₃ : C 3₆) (c₄ : C 4₆) (c₅ : C 5₆) : Π (x : 𝟔), C x
 := +-ind 𝟑 𝟑 C (ind₃ (λ (x : 𝟑), C (0₂, x)) c₀ c₁ c₂) (ind₃ (λ (x : 𝟑), C (1₂, x)) c₃ c₄ c₅)

def 𝟕 : U := + 𝟑 𝟒
def 0₇ : 𝟕 := inl 𝟑 𝟒 0₃
def 1₇ : 𝟕 := inl 𝟑 𝟒 1₃
def 2₇ : 𝟕 := inl 𝟑 𝟒 2₃
def 3₇ : 𝟕 := inr 𝟑 𝟒 0₄
def 4₇ : 𝟕 := inr 𝟑 𝟒 1₄
def 5₇ : 𝟕 := inr 𝟑 𝟒 2₄
def 6₇ : 𝟕 := inr 𝟑 𝟒 3₄
def ind₇ (C : 𝟕 → U) (c₀ : C 0₇) (c₁ : C 1₇) (c₂ : C 2₇) (c₃ : C 3₇) (c₄ : C 4₇) (c₅ : C 5₇) (c₆ : C 6₇) : Π (x : 𝟕), C x
 := +-ind 𝟑 𝟒 C (ind₃ (λ (x : 𝟑), C (0₂, x)) c₀ c₁ c₂) (ind₄ (λ (x : 𝟒), C (1₂, x)) c₃ c₄ c₅ c₆)