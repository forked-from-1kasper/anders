module logic where
import library/foundations/mltt/either

def ¬ (A : U) := A → 𝟎
def CL (A : U) := ¬ (¬ A)

-- Theorem 1.17
-- https://electives.hse.ru/data/2017/10/16/1159321542/Book-Part2.pdf

def IPC→CL (A : U) : A → CL A := λ (x : A) (φ : ¬ A), φ x

def classical-dneg (A : U) : CL (¬ (¬ A) → A)
 := λ (f : ¬ (¬ (¬ A) → A)), f (λ (g : ¬ (¬ A)), ind₀ A (g (λ (x : A), f (λ (h : ¬ (¬ A)), x))))

def classical-lem (A : U) : CL (+ (¬ A) A)
 := λ (f : ¬ (+ (¬ A) A)), f (0₂, λ (x : A), f (1₂, x))

def classical-mp (A B : U) : CL A → CL (A → B) → CL B
 := λ (f : CL A) (g : CL (A → B)) (h : ¬ B), g (λ (φ : A → B), f (λ (x : A), h (φ x)))

def classical-linearity (A B : U) : CL (+ (A → B) (B → A))
 := λ (f : ¬ (+ (A → B) (B → A))), f (0₂, λ (x : A), ind₀ B (f (1₂, λ (y : B), x)))

def classical-deduction (A B : U) : (CL A → CL B) → CL (A → B)
 := λ (f : CL A → CL B) (g : ¬ (A → B)), f (λ (h : ¬ A), g (λ (x : A), ind₀ B (h x))) (λ (y : B), g (λ (x : A), y))

def classical-prod-intro (A B : U) (a : CL A) (b : CL B) : CL (A × B) :=
classical-mp B (A × B) b
  (classical-mp A (B → A × B) a
    (IPC→CL (A → B → A × B)
      (λ (a′ : A) (b′ : B), (a′, b′))))

def classical-pr₁ (A B : U) (φ : CL (A × B)) : CL A :=
classical-mp (A × B) A φ (IPC→CL ((A × B) → A) (λ (w : A × B), w.1))

def classical-pr₂ (A B : U) (φ : CL (A × B)) : CL B :=
classical-mp (A × B) B φ (IPC→CL ((A × B) → B) (λ (w : A × B), w.2))

