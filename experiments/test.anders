def id (A : U) (a : A) : A := a
def idfun : Î  (Aâ€² : U), Aâ€² â†’ Aâ€² := Î» (A : U) (a : A), a

def sigma/intro (A : U) (B : A â†’ U) (x : A) (u : B (id A x)) : Î£ (x : A), B x := (x, u)
def sigma/projâ‚‚ : Î  (A : U) (B : A â†’ U) (z : Î£ (x : A), B x), B z.1 := Î» (A : U) (B : A â†’ U) (z : Î£ (x : A), B x), z.2
def const (A : U) (B : U) (a : A) (b : B) : A := a
def test : Î  (A : U) (B : U), (A â†’ B) â†’ A â†’ B := Î» (A : U) (B : U) (f : A â†’ B) (x : A), f x
def trio : Uâ‚‚ := Î£ (fst : Uâ‚) (snd : Uâ‚), Uâ‚
def lower : Uâ‚â‚â‚‚â‚â‚‚ := Uâ‚â‚â‚‚â‚â‚
def instance : trio := (U, U â†’ U, U â†’ U â†’ U)

def hole (A B C X Y Z : U) (a : A) (b : B) (x : X) : Y := ?

def holeâ€² : Î  (A : U), A â†’ A â†’ Î£ (B : U), B := ?

def pair (A B : U) := Î£ (first : A) (second : B), U
def pair-first  (A B : U) (X : pair A B) : A := X.first
def pair-second (A B : U) (X : pair A B) : B := X.second

def fst-snd (A B C : U) (w : Î£ (_ : A), Î£ (_ : B), C) : B := w.2.1

def not : ğŸ â†’ ğŸ := indâ‚‚ (Î» (_ : ğŸ), ğŸ) 1â‚‚ 0â‚‚
def and : ğŸ â†’ ğŸ â†’ ğŸ := indâ‚‚ (Î» (_ : ğŸ), ğŸ â†’ ğŸ) (const ğŸ ğŸ false) (idfun ğŸ)
def or : ğŸ â†’ ğŸ â†’ ğŸ := indâ‚‚ (Î» (_ : ğŸ), ğŸ â†’ ğŸ) (idfun ğŸ) (const ğŸ ğŸ true)

def zarith : Uâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚â‚ˆâ‚„â‚„â‚†â‚‡â‚„â‚„â‚€â‚‡â‚ƒâ‚‡â‚€â‚‰â‚…â‚…â‚â‚†â‚â‚… := Uâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚ˆâ‚â‚ˆâ‚„â‚„â‚†â‚‡â‚„â‚„â‚€â‚‡â‚ƒâ‚‡â‚€â‚‰â‚…â‚…â‚â‚†â‚â‚„

section
  section
    variables (X : U) (Y : U)

    def constâ€² (x : X) (y : Y) := x
  end

  variables (A : U)
  def idfunâ€² : A â†’ A := Î» (x : A), x
end

def testâ€² := U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U â†’ U

macrovariables A B C D

macro â†’Â² A := A â†’ A
macro â†’Â³ A := A â†’ (â†’Â² A)
macro â†’â´ A := A â†’ (â†’Â³ A)
macro â†’âµ A := A â†’ (â†’â´ A)
macro â†’â¶ A := A â†’ (â†’âµ A)
macro â†’â· A := A â†’ (â†’â¶ A)

#eval â†’â· U

macrovariables X Y

infix 25 =
macro X = Y := PathP (<_> typeof X) X Y

def refl (A : U) (a : A) : a = a :=
<_> a

def symm (A : U) (a b : A) (p : a = b) : b = a :=
<i> p @ -i

def trans (A : U) (a b c : A) (p : a = b) (q : b = c) : a = c :=
<i> hcomp A (i âˆ¨ -i) (Î» (j : I), [(i = 0) â†’ a, (i = 1) â†’ q @ j]) (p @ i)
