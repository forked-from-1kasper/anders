module test-equiv where

def ∂ (i : I) := i ∨ -i
def id (α : U) (a : α) : α := a
def fiber (A B : U) (f: A -> B) (y : B): U := Σ (x : A), PathP (<_>B) y (f x)
def isContr (A: U) : U := Σ (x: A), Π (y: A), PathP (<_>A) x y
def isEquiv (A B : U) (f : A -> B) : U := Π (y : B), isContr (fiber A B f y)
def equiv (A B : U) : U := Σ (f : A -> B), isEquiv A B f
def singl (A: U) (a: A): U := Σ (x: A), PathP (<_>A) a x
def eta (A: U) (a: A): singl A a := (a, <_>a)
def contr (A : U) (a b : A) (p : PathP (<_>A) a b) : PathP (<_>singl A a) (eta A a) (b, p) := <i> (p @ i, <j> p @ i /\ j)
def isContrSingl (A : U) (a : A) : isContr (singl A a) := (eta A a,(\ (z : singl A a), contr A a z.1 z.2))
def idEquiv (A : U) : equiv A A := (id A, isContrSingl A)
def univ-formation (A B : U) := equiv A B -> PathP (<_>U) A B
def univ-intro (A B : U) : univ-formation A B := λ (p : equiv A B), <i> Glue B (∂ i) [(i = 0) → (A, p), (i = 1) → (B, idEquiv B)]
def univ-elim (A B : U) (p : PathP (<_> U) A B) : equiv A B := transp (<i> equiv A (p @ i)) 0 (idEquiv A)

def univ-computation (A B : U) (p : PathP (<_>U) A B) : PathP (<_> PathP (<_> U) A B) (univ-intro A B (univ-elim A B p)) p
 := <j i> Glue B (∂ j \/ ∂ i) [ (i = 0) → (A, univ-elim A B p), (i = 1) → (B, univ-elim B B (<k> B)),
                                (j = 1) → (p @ i, univ-elim (p @ i) B (<k> p @ (i \/ k))) ]


