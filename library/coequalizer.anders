{- Homotopy Type Theory:
   - Coequalizer.
   - S¹ sphere.

   Copyright (c) Groupoid Infinity, 2014-2022. -}
   
module coequalizer where
import library/induction
import library/path

-- In Anders we take Coeq as core primitive and by using it with W-types
-- we then express more ordinary Pushouts and more general HITs like Suspension and n-Sphere.
-- The motivation behind Coeq is van Kampen theorem as in [1].

-- [1]. Nicolai Kraus, Jakob von Raumer.
-- Path spaces of higher inductive types in homotopy type theory.
-- http://pure-oai.bham.ac.uk/ws/files/84880431/Path_Spaces.pdf

-- [Bauer, Gross, Lumsdaine, Shulman, Sozeau, Spitters] 2016 Coequalizer (Coq HoTT)
-- The HoTT Library: A formalization of homotopy type theory in Coq
-- https://arxiv.org/pdf/1610.04591.pdf

axiom //~ (A B : U) (f g : A -> B) : U
axiom ι (A B : U) (f g : A -> B) : B -> //~ A B f g
axiom resp (A B : U) (f g : A -> B) (x : A) : Path (//~ A B f g) (ι A B f g (f x)) (ι A B f g (g x))
axiom //~-ind (A B : U) (f g : A -> B) (X : //~ A B f g -> U) (i : Π (b : B), X (ι A B f g b))
    : (Π (x : A), PathP (<i> X (resp A B f g x @ i)) (i (f x)) (i (g x))) → (Π (z : //~ A B f g), X z)
axiom //~-ind-β₁ (A B : U) (f g : A → B) (X : //~ A B f g -> U) (i : Π (b : B), X (ι A B f g b))
      (ρ : Π (x : A), PathP (<i> X (resp A B f g x @ i)) (i (f x)) (i (g x))) (b : B)
    : Path (X (ι A B f g b)) (//~-ind A B f g X i ρ (ι A B f g b)) (i b)

-- //~-ind-β₁ need to be definitional to write this properly (i.e. without transp)
{-
axiom //~-ind-β₂ (A B : U) (f g : A → B) (X : //~ A B f g -> U) (i : Π (b : B), X (ι A B f g b))
  (ρ : Π (x : A), PathP (<i> X (resp A B f g x @ i)) (i (f x)) (i (g x))) (x : A) :
  Path (PathP (<j> X (resp A B f g x @ j)) (i (f x)) (i (g x)))
       (<j> //~-ind A B f g X i ρ (resp A B f g x @ j)) (ρ x)
-}

-- [Caglayan] 2014

def pushout (A B C : U) (f : C → A) (g : C → B) : U
 := //~ C (+ A B) (∘ C A (+ A B) (inl A B) f) (∘ C B (+ A B) (inr A B) g)
def po₁ (A B C: U) (f: C -> A) (g: C -> B) (a: A) : pushout A B C f g
 := ι C (+ A B) (∘ C A (+ A B) (inl A B) f) (∘ C B (+ A B) (inr A B) g) (inl A B a)
def po₂ (A B C: U) (f: C -> A) (g: C -> B) (b: B) : pushout A B C f g
 := ι C (+ A B) (∘ C A (+ A B) (inl A B) f) (∘ C B (+ A B) (inr A B) g) (inr A B b)
def po₃ (A B C: U) (f: C -> A) (g: C -> B) (c: C)
  : Path (pushout A B C f g) (po₁ A B C f g (f c)) (po₂ A B C f g (g c))
 := resp C (+ A B) (∘ C A (+ A B) (inl A B) f) (∘ C B (+ A B) (inr A B) g) c

-- [Shulman] 2015

def S¹ : U := //~ 𝟏 𝟏 (id 𝟏) (id 𝟏)
def base : S¹ := ι 𝟏 𝟏 (id 𝟏) (id 𝟏) ★
def loop : Path S¹ base base := resp 𝟏 𝟏 (id 𝟏) (id 𝟏) ★ 

-- [Caglayan] 2018

def 𝚺 (A: U) : U := pushout 𝟏 𝟏 A (\(_: A), ★) (\(_: A), ★)
def 𝜎₁ (A: U): 𝚺 A := po₁ 𝟏 𝟏 A (\(_: A), ★) (\(_: A), ★) ★
def 𝜎₂ (A: U): 𝚺 A := po₂ 𝟏 𝟏 A (\(_: A), ★) (\(_: A), ★) ★
def 𝜎₃ (A: U) (a: A) : Path (𝚺 A) (𝜎₁ A) (𝜎₂ A) := po₃ 𝟏 𝟏 A (\(_: A), ★) (\(_: A), ★) a

