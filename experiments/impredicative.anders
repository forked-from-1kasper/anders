{- Impredicative Encoding of Inductive Types:
   - Unit.
   Copyright (c) Groupoid Infinity, 2014-2021. -}

module impredicative where
-- option impredicative true
option girard true
import experiments/path

def ⚬ (A B C: U) : U := (B -> C) -> (A -> B) -> (A -> C)
def ∘ (A B C : U) : ⚬ A B C := \ (g: B -> C) (f: A -> B) (x: A), g (f x)
def isSet (A : U) : U := Π (a b : A) (a0 b0 : PathP (<i> A) a b), PathP (<i> PathP (<i> A) a b) a0 b0
def isProp (A : U) : U := Π (a b : A), PathP (<i> A) a b

def naturality (X Y: U) (f : X -> Y) (a : X -> X) (b : Y -> Y) : U := Path (X -> Y) (∘ X X Y f a) (∘ X Y Y b f)
def ①' : U := Π (X : U), isSet X -> X -> X
def is-① (one: ①') : U := Π (X Y: U) (x: isSet X) (y: isSet Y) (f: X -> Y), naturality X Y f (one X x) (one Y y)
def ① : U := Σ (x: ①'), is-① x
def ①-★ : ① := ((\ (X: U) (_: isSet X), \(x:X), x), (\ (X Y: U) (_: isSet X) (_: isSet Y), idp (X -> Y)))
def ①-rec (C: U) (s: isSet C) (c: C): ① -> C := \ (z: ①), z.1 C s c
axiom ①-η (z: ①): Path ① ①-★ z
def ①-ind (P: ① -> U) (a: ①): P ①-★ -> P a := subst ① P ①-★ a (①-η a)
def ①-β (C: U) (s: isSet C) (c: C): Path C (①-rec C s c ①-★) c := idp C c
def ①-condition (n: ①'): isProp (is-① n) :=
    \ (f g: is-① n), <h> \ (x y: U) (X: isSet x) (Y: isSet y) (F: x -> y), <i> \ (R: x),
    Y (F (n x X R)) (n y Y (F R)) (<j> f x y X Y F @ j R) (<j> g x y X Y F @ j R) @ h @ i

{-
   Literature:

   [1]. https://github.com/sspeight93/Papers/
   [2]. https://homotopytypetheory.org/2017/10/11/impredicative-encodings-of-inductive-types-in-hott/
   [3]. https://www.newton.ac.uk/files/seminar/20170711090010001-1009680.pdf
-}

{-
   Abstract:

   Church Encoding Nat:

      Nat = (X: U) -> (X -> X) -> X -> X

   Impredicative Encoding Unit:

      Unit = (X: U) -> isSet X -> X -> X
      Unit_Encoding = (one: Unit)
                    * ((X Y: U) (x: isSet X) (y:isSet Y) (f:X->Y)
                           -> naturality X Y f (one X x) (one Y y))

   Impredicative Encoding Nat:

      Nat  = (X: U) -> isSet X -> (X -> X) -> (X -> X)
      Nat_Encoding = (one: Nat)
                    * ((X Y: U) (x: isSet X) (y:isSet Y) (f:X->Y)
                           -> naturality X Y f (one X x) (one Y y))

   Motivation is to have algebra structure that could be used with any coherent carrier.
   Impredicativity means that we can land inductive type in any universe.
   E.g. one can change the predicate from isSet to isProp for truncations or to higher n-types.
   You can also model HIT using impredicative encoding. Universes could be impredicative
   and univalent at the same time.

      Truncation ||A|| parametrized by (A:U) type = (X: U) -> isProp X -> (A -> X) -> X
      S^1 = (X:U) -> isGroupoid X -> (x:X) -> Path X x x -> X
      Arbitrary (A:U) type = (X: U) -> isSet X -> (A -> X) -> X
-}

