{- Inductive Basis: https://homotopy.dev/foundations/mltt/inductive/
   - 0, 1, 2, W types;

   HoTT 5.3 W-Types

   Copyright (c) Groupoid Infinity, 2014-2022. -}

module inductive where
import library/foundations/univalent/path
option girard true

-- Steve Awodey, Nicola Gambino, Kristina Sojakova
-- Inductive Types in Homotopy Type Theory
-- https://arxiv.org/pdf/1201.3898.pdf

-- Jasper Hugunin
-- Why not W?
-- https://jashug.github.io/papers/whynotw.pdf

-- Fredrik Nordvall Forsberg and Anton Setzer
-- A finite axiomatisation of inductive-inductive definitions
-- https://personal.cis.strath.ac.uk/fredrik.nordvall-forsberg/papers/indind_finite.pdf

-- Primitives: 0, 1, 2, W

def 0-ind (C: 𝟎 → U) (z: 𝟎) : C z := ind₀ (C z) z
def 1-ind (C: 𝟏 → U) (x: C ★) (z: 𝟏) : C z := ind₁ C x z
def 2-ind (C: 𝟐 → U) (x: C 0₂) (y: C 1₂) (z: 𝟐) : C z := ind₂ C x y z

def W′ (A : U) (B : A → U) : U := W (x: A), B x
def sup′ (A : U) (B : A → U) (x : A) (f : B x → W′ A B) : W′ A B := sup A B x f

def W-ind (A : U) (B : A → U) (C : (W (x : A), B x) → U)
    (g : Π (x : A) (f : B x → (W (x : A), B x)), (Π (b : B x), C (f b)) → C (sup A B x f))
    (a : A) (f : B a → (W (x : A), B x)) (b : B a) : C (f b) := indᵂ A B C g (f b)

def indᵂ-β (A : U) (B : A → U) (C : (W (x : A), B x) → U)
    (g : Π (x : A) (f : B x → (W (x : A), B x)), (Π (b : B x), C (f b)) → C (sup A B x f)) (a : A) (f : B a → (W (x : A), B x))
  : PathP (<_> C (sup A B a f)) (indᵂ A B C g (sup A B a f)) (g a f (λ (b : B a), indᵂ A B C g (f b)))
 := <_> g a f (λ (b : B a), indᵂ A B C g (f b))

def trans-W (A : I → U) (B : Π (i : I), A i → U) (a : A 0) (f : B 0 a → (W (x : A 0), B 0 x)) : W (x : A 1), B 1 x
 := sup (A 1) (B 1) (transp (<i> A i) 0 a) (transp (<i> B i (transFill (A 0) (A 1) (<j> A j) a @ i) → (W (x : A i), B i x)) 0 f)

def trans-W′ (A : I → U) (B : Π (i : I), A i → U) (a : A 0) (f : B 0 a → (W (x : A 0), B 0 x)) : W (x : A 1), B 1 x
 := transp (<i> W (x : A i), B i x) 0 (sup (A 0) (B 0) a f)

def trans-W-is-correct (A : I → U) (B : Π (i : I), A i → U) (a : A 0) (f : B 0 a → (W (x : A 0), B 0 x))
  : Path (W (x : A 1), B 1 x) (trans-W A B a f) (trans-W′ A B a f)
 := <_> trans-W A B a f

def hcomp-W (A : U) (B : A → U) (r : I) (a : I → Partial A r)
    (f : Π (i : I), PartialP [(r = 1) → B (a i 1=1) → (W (x : A), B x)] r)
    (a₀ : A[r ↦ a 0]) (f₀ : (B (ouc a₀) → (W (x : A), B x))[r ↦ f 0]) : W (x : A), B x
 := sup A B (hcomp A r a (ouc a₀))
            (hcomp (B (hcomp A r a (ouc a₀)) → (W (x : A), B x)) r
                   (λ (i : I), [(r = 1) → λ (b : B (a 1 1=1)), (f i 1=1) (transp (<j> B (a (-j ∨ i) 1=1)) 0 b)])
                   (λ (b : B (hcomp A r a (ouc a₀))), (ouc f₀) (transp (<j> B (hfill A r a a₀ -j)) 0 b)))

def hcomp-W′ (A : U) (B : A → U) (r : I) (a : I → Partial A r)
    (f : Π (i : I), PartialP [(r = 1) → B (a i 1=1) → (W (x : A), B x)] r)
    (a₀ : A[r ↦ a 0]) (f₀ : (B (ouc a₀) → (W (x : A), B x))[r ↦ f 0]) : W (x : A), B x
 := hcomp (W (x : A), B x) r (λ (i : I), [(r = 1) → sup A B (a i 1=1) (f i 1=1)]) (sup A B (ouc a₀) (ouc f₀))

def hcomp-W-is-correct (A : U) (B : A → U) (r : I) (a : I → Partial A r)
    (f : Π (i : I), PartialP [(r = 1) → B (a i 1=1) → (W (x : A), B x)] r)
    (a₀ : A[r ↦ a 0]) (f₀ : (B (ouc a₀) → (W (x : A), B x))[r ↦ f 0]) :
    Path (W (x : A), B x) (hcomp-W A B r a f a₀ f₀) (hcomp-W′ A B r a f a₀ f₀) :=
<_> hcomp-W A B r a f a₀ f₀
