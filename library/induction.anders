module induction where
option girard true

-- Steve Awodey, Nicola Gambino, Kristina Sojakova
-- Inductive Types in Homotopy Type Theory
-- https://arxiv.org/pdf/1201.3898.pdf

def 0-ind (C: empty -> U) (z: empty) : C z := ind₀ (C z) z
def 1-ind (C: unit -> U) (x: C star) (z: unit) : C z := ind₁ C x z
def 2-ind (C: bool -> U) (x: C 0₂) (y: C 1₂) (z: bool) : C z := ind₂ C x y z

def indᵂ-β (A : U) (B : A → U) (C : (W (x : A), B x) → U)
   (g : Π (x : A) (f : B x → (W (x : A), B x)),
   (Π (b : B x), C (f b)) → C (sup A B x f))
   (a : A) (f : B a → (W (x : A), B x)) :
   PathP (<_> C (sup A B a f))
         (indᵂ A B C g (sup A B a f))
         (g a f (λ (b : B a), indᵂ A B C g (f b)))
 := <_> g a f (λ (b : B a), indᵂ A B C g (f b))

def ℕ := W (x : 𝟐), ind₂ (λ (_ : 𝟐), U) 𝟎 𝟏 x
def ℕ-ctor := ind₂ (λ (_ : 𝟐), U) 𝟎 𝟏

def zero : ℕ := sup 𝟐 ℕ-ctor 0₂ (ind₀ ℕ)
def succ (n : ℕ) : ℕ := sup 𝟐 ℕ-ctor 1₂ (λ (x : 𝟏), n)

def 𝟎→ℕ (C : ℕ → U) (f : 𝟎 → ℕ) : C zero → C (sup 𝟐 ℕ-ctor 0₂ f)
 := transp (<i> C (sup 𝟐 ℕ-ctor 0₂ (λ (x : 𝟎), ind₀ (PathP (<_> ℕ) (ind₀ ℕ x) (f x)) x @ i))) 0

def 𝟏→ℕ (C : ℕ → U) (f : 𝟏 → ℕ) : C (succ (f ★)) → C (sup 𝟐 ℕ-ctor 1₂ f)
 := transp (<i> C (sup 𝟐 ℕ-ctor 1₂ (λ (x : 𝟏), ind₁ (λ (y : 𝟏), PathP (<_> ℕ) (f ★) (f y)) (<_> f ★) x @ i))) 0

def ℕ-ind (C : ℕ → U) (z : C zero) (s : Π (n : ℕ), C n → C (succ n)) : Π (n : ℕ), C n
 := indᵂ 𝟐 ℕ-ctor C
    (ind₂ (λ (x : 𝟐), Π (f : ℕ-ctor x → ℕ), (Π (b : ℕ-ctor x), C (f b)) → C (sup 𝟐 ℕ-ctor x f))
          (λ (f : 𝟎 → ℕ) (g : Π (x : 𝟎), C (f x)), 𝟎→ℕ C f z)
          (λ (f : 𝟏 → ℕ) (g : Π (x : 𝟏), C (f x)), 𝟏→ℕ C f (s (f ★) (g ★))))

def ℕ-rec (C : U) (z : C) (s : ℕ → C → C) : ℕ → C := ℕ-ind (λ (_ : ℕ), C) z s
def ℕ-iter (C : U) (z : C) (s : C → C) : ℕ → C := ℕ-rec C z (λ (_ : ℕ), s)
def ℕ-case (C : U) (z s : C) : ℕ → C := ℕ-iter C z (λ (_ : C), s)

def + (A B: U) : U := Σ (x : 𝟐), ind₂ (λ (_ : 𝟐), U) A B x
def inl (A B : U) (a : A) : + A B := (0₂, a)
def inr (A B : U) (b : B) : + A B := (1₂, b)
def +-ind (A B : U) (C : + A B → U) (f : Π (x : A), C (inl A B x)) (g : Π (y : B), C (inr A B y)) (w : + A B) : C w
 := ind₂ (λ (x : 𝟐), Π (u : ind₂ (λ (_ : 𝟐), U) A B x), C (x, u)) f g w.1 w.2

def maybe (A : U) : U := + 𝟏 A
def nothing (A : U) : maybe A := (0₂, ★)
def just (A : U) (a : A) : maybe A := (1₂, a)
def maybe-ind (A : U) (P: maybe A -> U) (n: P (nothing A)) (j: Π (x: A), P (just A x)) : Π (a: maybe A), P a
 := +-ind 𝟏 A P (ind₁ (λ (x : 𝟏), P (0₂, x)) n) j

def N : U := ℕ
def Fin : ℕ → U := ℕ-iter U 𝟎 (+ 𝟏)
def fzero (n : ℕ) : Fin (succ n) := (0₂, ★)
def fsucc (n : ℕ) (m : Fin n) : Fin (succ n) := (1₂, m)
def Fin-ind (T : ℕ → U) (m: ℕ) (z: Π (n: ℕ), T (succ n)) (s: Π (n: ℕ), T n → T (succ n)) : Fin m → T m
 := ?

def Vec (A: U) : ℕ → U := ℕ-iter U 𝟏 (λ (X : U), A × X)
def vzero (A: U) : Vec A zero := ★
def vsucc (A: U) (n : ℕ) (head: A) (tail : Vec A n) : Vec A (succ n) := (head,tail)
def Vec-ind (A: U) (B: ℕ → U) (m: ℕ) (z: B zero) (s: Π (n: ℕ), A → B n → B (succ n)) : Vec A m → B m
 := ?

def 𝟑 : U := Fin (succ (succ (succ zero)))
def 0₃ : 𝟑 := fzero (succ (succ zero))
def 1₃ : 𝟑 := fsucc (succ (succ zero)) (fzero (succ zero))
def 2₃ : 𝟑 := fsucc (succ (succ zero)) (fsucc (succ zero) (fzero zero))

def ind₃ (C : 𝟑 → U) (a : C 0₃) (b : C 1₃) (c : C 2₃) : Π (x : 𝟑), C x
 := +-ind 𝟏 (+ 𝟏 (+ 𝟏 𝟎)) C (ind₁ (λ (x : 𝟏), C (0₂, x)) a)
            (+-ind 𝟏 (+ 𝟏 𝟎) (λ (y : + 𝟏 (+ 𝟏 𝟎)), C (1₂, y)) (ind₁ (λ (x : 𝟏), C (1₂, (0₂, x))) b)
                     (+-ind 𝟏 𝟎 (λ (x : + 𝟏 𝟎), C (1₂, (1₂, x))) (ind₁ (λ (x : 𝟏), C (1₂, (1₂, (0₂, x)))) c)
                              (λ (y : 𝟎), ind₀ (C (1₂, (1₂, (1₂, y)))) y)))