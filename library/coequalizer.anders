{- Homotopy Type Theory:
   - Coequalizer.
   - S¬π sphere and ùëõ-sphere.
   - Pushout.
   - Suspension.

   HoTT 6.8 Pushouts

   Copyright (c) Groupoid Infinity, 2014-2022. -}
   
module coequalizer where
import library/induction

-- In Anders we take Coeq as core primitive and by using it with W-types
-- we then express more ordinary Pushouts and more general HITs like Suspension and n-Sphere.
-- The motivation behind Coeq is van Kampen theorem as in [1].

-- [1]. Nicolai Kraus, Jakob von Raumer.
-- Path spaces of higher inductive types in homotopy type theory.
-- http://pure-oai.bham.ac.uk/ws/files/84880431/Path_Spaces.pdf

-- [Bauer, Gross, Lumsdaine, Shulman, Sozeau, Spitters] 2016 Coequalizer (Coq HoTT)
-- The HoTT Library: A formalization of homotopy type theory in Coq
-- https://arxiv.org/pdf/1610.04591.pdf

axiom coequ (A B : U) (f g : A -> B) : U
axiom Œπ (A B : U) (f g : A -> B) : B -> coequ A B f g
axiom resp (A B : U) (f g : A -> B) (x : A) : Path (coequ A B f g) (Œπ A B f g (f x)) (Œπ A B f g (g x))
axiom coequ-ind (A B : U) (f g : A -> B) (X : coequ A B f g -> U) (i : Œ† (b : B), X (Œπ A B f g b))
    : (Œ† (x : A), PathP (<i> X (resp A B f g x @ i)) (i (f x)) (i (g x))) ‚Üí (Œ† (z : coequ A B f g), X z)
axiom coequ-ind-Œ≤‚ÇÅ (A B : U) (f g : A ‚Üí B) (X : coequ A B f g -> U) (i : Œ† (b : B), X (Œπ A B f g b))
      (œÅ : Œ† (x : A), PathP (<i> X (resp A B f g x @ i)) (i (f x)) (i (g x))) (b : B)
    : Path (X (Œπ A B f g b)) (coequ-ind A B f g X i œÅ (Œπ A B f g b)) (i b)

-- coequ-ind-Œ≤‚ÇÅ need to be definitional to write this properly (i.e. without transp)
{-
axiom coequ-ind-Œ≤‚ÇÇ (A B : U) (f g : A ‚Üí B) (X : coequ A B f g -> U) (i : Œ† (b : B), X (Œπ A B f g b))
  (œÅ : Œ† (x : A), PathP (<i> X (resp A B f g x @ i)) (i (f x)) (i (g x))) (x : A) :
  Path (PathP (<j> X (resp A B f g x @ j)) (i (f x)) (i (g x)))
       (<j> coequ-ind A B f g X i œÅ (resp A B f g x @ j)) (œÅ x)
-}

-- [Caglayan] 2014

def pushout (A B C : U) (f : C ‚Üí A) (g : C ‚Üí B) : U := coequ C (+ A B) (‚àò C A (+ A B) (inl A B) f) (‚àò C B (+ A B) (inr A B) g)
def po‚ÇÅ (A B C: U) (f: C -> A) (g: C -> B) (a: A) : pushout A B C f g := Œπ C (+ A B) (‚àò C A (+ A B) (inl A B) f) (‚àò C B (+ A B) (inr A B) g) (inl A B a)
def po‚ÇÇ (A B C: U) (f: C -> A) (g: C -> B) (b: B) : pushout A B C f g := Œπ C (+ A B) (‚àò C A (+ A B) (inl A B) f) (‚àò C B (+ A B) (inr A B) g) (inr A B b)
def po‚ÇÉ (A B C: U) (f: C -> A) (g: C -> B) (c: C) : Path (pushout A B C f g) (po‚ÇÅ A B C f g (f c)) (po‚ÇÇ A B C f g (g c))
 := resp C (+ A B) (‚àò C A (+ A B) (inl A B) f) (‚àò C B (+ A B) (inr A B) g) c

-- [Shulman] 2015

def S¬π : U := coequ ùüè ùüè (id ùüè) (id ùüè)
def base : S¬π := Œπ ùüè ùüè (id ùüè) (id ùüè) ‚òÖ
def loop : Path S¬π base base := resp ùüè ùüè (id ùüè) (id ùüè) ‚òÖ 

-- [Caglayan] 2018

def ùö∫ (A: U) : U := pushout ùüè ùüè A (\(_: A), ‚òÖ) (\(_: A), ‚òÖ)
def ùúé‚ÇÅ (A: U): ùö∫ A := po‚ÇÅ ùüè ùüè A (\(_: A), ‚òÖ) (\(_: A), ‚òÖ) ‚òÖ
def ùúé‚ÇÇ (A: U): ùö∫ A := po‚ÇÇ ùüè ùüè A (\(_: A), ‚òÖ) (\(_: A), ‚òÖ) ‚òÖ
def ùúé‚ÇÉ (A: U) (a: A) : Path (ùö∫ A) (ùúé‚ÇÅ A) (ùúé‚ÇÇ A) := po‚ÇÉ ùüè ùüè A (\(_: A), ‚òÖ) (\(_: A), ‚òÖ) a

def sphere : ‚Ñï -> U := ‚Ñï-iter U ùüê ùö∫

def full (A : U) (R : A ‚Üí A ‚Üí U) := Œ£ (x y : A), R x y
def quot (A : U) (R : A ‚Üí A ‚Üí U) := coequ (full A R) A (Œª (w : full A R), w.1) (Œª (w : full A R), w.2.1)
def quot-elem (A : U) (R : A ‚Üí A ‚Üí U) : A ‚Üí quot A R := Œπ (full A R) A (Œª (w : full A R), w.1) (Œª (w : full A R), w.2.1)
def quot-glue (A : U) (R : A ‚Üí A ‚Üí U) (x y : A) (œÅ : R x y)
  : Path (quot A R) (quot-elem A R x) (quot-elem A R y)
 := resp (full A R) A (Œª (w : full A R), w.1) (Œª (w : full A R), w.2.1) (x, y, œÅ)
