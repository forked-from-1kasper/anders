module induction where
option girard true

-- Steve Awodey, Nicola Gambino, Kristina Sojakova
-- Inductive Types in Homotopy Type Theory
-- https://arxiv.org/pdf/1201.3898.pdf

def indᵂ-β (A : U) (B : A → U) (C : (W (x : A), B x) → U)
    (g : Π (x : A) (f : B x → (W (x : A), B x)),
    (Π (b : B x), C (f b)) → C (sup A B x f))
    (a : A) (f : B a → (W (x : A), B x))
 := g a f (λ (b : B a), indᵂ A B C g (f b))

def indᵂ-β′ (A : U) (B : A → U) (C : (W (x : A), B x) → U)
    (g : Π (x : A) (f : B x → (W (x : A), B x)), (Π (b : B x), C (f b)) → C (sup A B x f))
    (a : A) (f : B a → (W (x : A), B x))
 := indᵂ A B C g (sup A B a f)

def ℕ := W (x : 𝟐), ind₂ (λ (_ : 𝟐), U) 𝟎 𝟏 x
def ℕ-ctor := ind₂ (λ (_ : 𝟐), U) 𝟎 𝟏

def zero : ℕ := sup 𝟐 ℕ-ctor 0₂ (ind₀ ℕ)
def succ (n : ℕ) : ℕ := sup 𝟐 ℕ-ctor 1₂ (λ (x : 𝟏), n)

def 𝟎→ℕ (C : ℕ → U) (f : 𝟎 → ℕ) : C zero → C (sup 𝟐 ℕ-ctor 0₂ f)
 := transp (<i> C (sup 𝟐 ℕ-ctor 0₂ (λ (x : 𝟎), ind₀ (PathP (<_> ℕ) (ind₀ ℕ x) (f x)) x @ i))) 0

def 𝟏→ℕ (C : ℕ → U) (f : 𝟏 → ℕ) : C (succ (f ★)) → C (sup 𝟐 ℕ-ctor 1₂ f)
 := transp (<i> C (sup 𝟐 ℕ-ctor 1₂ (λ (x : 𝟏), ind₁ (λ (y : 𝟏), PathP (<_> ℕ) (f ★) (f y)) (<_> f ★) x @ i))) 0

def ℕ-ind (C : ℕ → U) (z : C zero) (s : Π (n : ℕ), C n → C (succ n)) : Π (n : ℕ), C n
 := indᵂ 𝟐 ℕ-ctor C
    (ind₂ (λ (x : 𝟐), Π (f : ℕ-ctor x → ℕ), (Π (b : ℕ-ctor x), C (f b)) → C (sup 𝟐 ℕ-ctor x f))
          (λ (f : 𝟎 → ℕ) (g : Π (x : 𝟎), C (f x)), 𝟎→ℕ C f z)
          (λ (f : 𝟏 → ℕ) (g : Π (x : 𝟏), C (f x)), 𝟏→ℕ C f (s (f ★) (g ★))))

def ℕ-rec (C : U) (z : C) (s : ℕ → C → C) : ℕ → C := ℕ-ind (λ (_ : ℕ), C) z s
def ℕ-iter (C : U) (z : C) (s : C → C) : ℕ → C := ℕ-rec C z (λ (_ : ℕ), s)
def ℕ-case (C : U) (z s : C) : ℕ → C := ℕ-iter C z (λ (_ : C), s)
def N : U := ℕ

def + (A B: U) : U := Σ (x : 𝟐), ind₂ (λ (_ : 𝟐), U) A B x
def inl (A B : U) (a : A) : + A B := (0₂, a)
def inr (A B : U) (b : B) : + A B := (1₂, b)

def prod (A B: U) : U := Σ (x : A), B

def maybe (A : U) : U := + 𝟏 A
def nothing (A : U) : maybe A := (0₂, ★)
def just (A : U) (a : A) : maybe A := (1₂, a)

def Fin : ℕ → U := ℕ-ind (λ (_ : ℕ), U) 𝟎 (\(_: ℕ), + 𝟏)
def Vec (A: U) : ℕ → U := ℕ-ind (λ (_ : ℕ), U) A (\(_: ℕ), prod A)
