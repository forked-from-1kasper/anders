{- Equivalence:
   - Fibers;
   - Contractability of Fibers and Singletons;
   - Equivalence.
   - Surjective, Injective, Embedding, Hae;
   - Theorems, Gluening;
   - Theorem of univalence.
   Copyright (c) Groupoid Infinity, 2014-2021.

   HoTT 4.6 Surjections and Embedding -}

module equiv where
import library/path

def fiber (A B : U) (f: A -> B) (y : B): U := Σ (x : A), Path B y (f x)
def isContr' (A: U) : U := Σ (x: A), Π (y: A), Path A x y
def isEquiv (A B : U) (f : A -> B) : U := Π (y : B), isContr (fiber A B f y)
def equiv (A B : U) : U := Σ (f : A -> B), isEquiv A B f
def contrSingl (A : U) (a b : A) (p : Path A a b) : Path (Σ (x : A), Path A a x) (a,<_>a) (b,p) := <i> (p @ i, <j> p @ i /\ j)
def idIsEquiv (A : U) : isEquiv A A (id A) := \ (a : A), ((a,<_>a),\ (z : fiber A A (id A) a), contrSingl A a z.1 z.2)
def idEquiv (A : U) : equiv A A := (id A, isContrSingl A)
def isInjective (A B : U) (f : A -> B) : U := Π (x y : A), Path B (f x) (f y) -> Path A x y
def isInjective' (A B : U) (f : A -> B): U := Π (b : B), isProp (fiber A B f b)
def injective (A B : U) : U := Σ (f : A -> B), isInjective A B f
def isEmbedding (A B : U) (f : A -> B) : U := Π (x y : A), isEquiv (Path A x y) (Path B (f x) (f y)) (cong A B f x y)
def embedding (A B : U) : U := Σ (f : A -> B), isEmbedding A B f
def inv-equiv (A B : U) (w : equiv A B) : B -> A := λ (y : B), (w.2 y).1.1
def ret-equiv (A B : U) (w : equiv A B) (y : B) : Path B (w.1 (inv-equiv A B w y)) y := <i> (w.2 y).1.2 @ -i
def sec-equiv (A B : U) (w : equiv A B) (x : A) : Path A (inv-equiv A B w (w.1 x)) x := <i> ((w.2 (w.1 x)).2 (x, <j> w.1 x) @ i).1
def Glue′ (A : U) (φ : I) (e : Partial (Σ (T : U), equiv T A) φ) : U := Glue A φ e

def isHae (A B : U) (f : A -> B): U :=
  Σ (g : B -> A) (eta_: Path (idᵀ A) (∘ A B A g f) (id A)) (eps_: Path (idᵀ B) (∘ B A B f g) (id B)),
  Π (x : A), Path B (f ((eta_ @ 0) x)) ((eps_ @ 0) (f x))
def hae (A B : U) : U := Σ (f : A -> B), isHae A B f

-- Univalence (Formation, Intro, Elim, Computation)

def univ-formation (A B : U) := equiv A B -> PathP (<_>U) A B

def univ-intro (A B : U) : univ-formation A B := λ (p : equiv A B), <i> Glue B (∂ i) [(i = 0) → (A, p), (i = 1) → (B, idEquiv B)]

def univ-elim (A B : U) (p : PathP (<_> U) A B) : equiv A B := transp (<i> equiv A (p @ i)) 0 (idEquiv A)

def zero (A B : U) : PathP (<_>U) A B -> PathP (<_>U) A B
  := \ (p : PathP (<_>U) A B), univ-intro A B (univ-elim A B p)

--def univ-computation (A B : U) (p : PathP (<_>U) A B) : PathP (<_> PathP (<_> U) A B) (zero A B p) p
-- := <j i> Glue B (∂ j \/ ∂ i) [ (i = 0) → (A, univ-elim A B p), (i = 1) → (B, univ-elim B B (<k> B)),
--                                (j = 1) → (p @ i, univ-elim (p @ i) B (<k> p @ (i \/ k))) ]

--def univ-uniqueness (A B : U) (w : equiv A B) : Path (A -> B) w.1 (pathToEquiv A B (equivToPath A B w)).1
--  := <i> \ (a : A), let b: B = w.1 a
--                       u: A = comp (<j>A) a []
--                       q: Path B (w.1 u) b = <i>w.1 (comp (<j>A) a [(i=1) -> <j>a])
--    in comp (<j> B) (comp (<j> B) (comp (<j> B) (comp (<j> B) (w.1 u)
--            [(i=0)->q]) [(i=0)-><k>b]) [(i=0)-><k>b]) [(i=0)-><k>b]
